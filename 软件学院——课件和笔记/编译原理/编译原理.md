# 编译原理

> 作者：王少博 时间原因没有整理完全

## ==Chapter 1 绪论==

### 1.1 程序设计语言

1. 机器语言：每一个具体的计算机系统都具有自己的指令系统，以 0,1 代码表示的机器指令所构成的语言

2. 汇编语言：适当的**助记符**来表示指令中的操作和操作数（与机器语言一一对应）

3. 高级语言：其表示方法更接近于待解问题的表示方法，用于定义数据、描述运算、控制流程、传输数据

   > 汇编语言有两个缺点，所以会产生高级语言：
   >
   > 1. 汇编语言直接操作寄存器/内存，易发生严重错误
   >
   > 2. 不同机器因机器指令不同，所对应的汇编指令不同，所以难以扩展）

### 1.2 程序语言的翻译

1. 翻译程序：将某一种语言描述的程序(**源程序**)翻译成**等价的**另一种语言描述的程序(**目标程序**)的程序。

2. 翻译程序大分为分为：解释程序+编译程序

   - 解释程序：**边解释边执行**，不断读取源程序的语句，解释语句，读取此语句需要的数据， 根据执行结果读取下一条语句，继续解释执行，直到返回结果。动态地给数据。<font color="darkred">类似于同声传译</font>

      ![img](https://i.loli.net/2020/10/14/82gzlqLv6A5xoIY.jpg)

   - 编译程序：将源程序完整地转换成机器语言程序或汇编语言程序，然后再处理、执行的翻译程序。高级语言程序→汇编/机器语言程序。<font color="darkred">类似于通篇笔译</font>

     ![img](https://i.loli.net/2020/10/14/1f2w3EK6WNu95YJ.jpg)

   - 编译系统=编译程序+运行系统（源程序经过翻译得到目标程序（机器语言），再支撑环境中与输入交互，最终得到输出）

     > 1. 汇编程序：汇编->机器
     > 2. 交叉编译程序：汇编-><font color="red">另一台机器上的</font>机器语言
     > 3. 反汇编程序：机器->汇编
     > 4. 交叉编译程序：高级-><font color="red">另一台机器上的</font>机器语言/汇编语言
     > 5. 反编译程序：机器->高级
     > 6. 可变目标编译程序：高级-><font color="red">可选机器上的</font>机器语言/汇编语言
     > 7. 并行编译程序：编译时代码并行化
     > 8. 诊断编译程序：
     > 9. 优化编译程序：编译主要的工作量在提高编译后运行代码的效率上

### 1.3 编译程序/系统总体结构：

<img src="https://i.loli.net/2020/11/02/EymHJ47SiY5eqG9.png" alt="image-20201102152438006" style="zoom:50%;" />

语义分析和中间代码生成器一般一起完成，所以写在了一起。

> 分析：词法分析、语法分析、语义分析
>
> 综合：中间代码生成、代码优化、目标代码生成
>
> 辅助：符号表管理、出错处理

#### 1. 词法分析Scanner：

Input 字符串  Output token序列，即(种别码，属性值) 序对（属性值是 token 的机内表示）

- 从左到右扫描组成源程序的**字符串**，将其转换成**单词串**；
- 检查词法错误；进行标识符登记（sum，n 等）；
- 进行符号表管理

#### 2. 语法分析Parser: 最后得到一个语法树

Input token序列 Ouput 语法成分

- Parser组词成句，词组合为语法成分
- 构造分析书
- 指出语法错误
- 指导编译

#### 3. 语义分析

语法制导翻译=语法分析+语义分析（两者一起进行）

- 分析由语法分析器识别出来的语法成分的语义，通常按照**中间代码**形式表达操作

- 获取标识符的属性：类型、作用域
- 语义检查：运算的合法性、取值范围
- 子程序的静态绑定：代码的相对地址
- 变量的静态绑定：数据的相对地址

#### 4. 中间代码生成表示

1. 后缀表示、前缀表示、四元式表示（三地址码，有中间结果）、三元式表示（无中间结果，和四元式差不多）、语义树
2. 特点：简单规范、与机器无关、易于转换和优化
3. 缺点：中间代码是语义逐条翻译，效率不高，所以需要进行代码优化

#### 5. 代码优化

使得程序运行能够尽量节省存储空间，更有效利用机器资源，使得程序运行更快，效率更高，但必须等价

> 1. 与机器无关的优化；
>
>    局部优化：常量合并（提前运算、提取公因子）+ 全局优化：循环优化（强度削减（快替慢）、代码外提（循环不变量提出来））
>
> 2. 与机器有关的优化：
>
>    寄存器利用（减少访存次数）+体系结构+任务划分+存储策略（减少访存冲突）CPU寄存器<高速缓冲储存器<主存<本地磁盘<磁盘

#### 6. 目标代码生成

- 为中间代码中出现的运算对象分配存储单元、寄存器
- 将中间代码转换为目标机上的机器指令代码或汇编代码
- 对于源语言的各种语法成分，确定目标代码结构
- 制定中间代码到目标代码的翻译策略/算法

#### 7. 错误处理

进行各种错误的检查、报告、纠正，以及相应的续编译处理（错误定位、局部化）

- 词法分析阶段：拼写检查
- 语法分析阶段：表达式、句子、结构
- 语义分析阶段：类型匹配、参数匹配错误、非法转移问题

#### 8. 表格管理

管理各种符号表（常数、变量等），查找、填写源程序中出现的符号和编译程序生成的符号，为编译的各个阶段提供信息。一般用**哈希表**实现。

### 1.4 编译程序的组织

1. 阶段：词法分析->词法分析->语法分析与中间代码生成->代码优化->目标代码生成
   对应：单词串->语法树->语义树->中间代码->优化后的代码->汇编指令

   > 词法分析、语法分析、中间代码生成 这三个阶段还是一个顺序关系，不过可以在一轮中处理

2. 遍：可以把编译程序设计为多遍，**遍就是编译程序或中间结果的完整扫描**。每一遍扫描完成不同的任务。遍可以和阶段相对应，可以无关。一般来说，三个分析阶段（包括中间代码生成）做成一遍、代码优化一遍、目标代码生成做成一遍。遍数量的优化和语言、系统的目标、资源状况有关。

   - 多遍扫描：<font color="red">优点</font>：本遍扫描的结果作为下一遍地输入，本遍扫描中得到地信息在下一遍扫描中也可以获得更优化地程序，<font color="blue">缺点</font>：但是增加了访内存次数，也有潜在访外存次数增加

   - 单遍扫描：分析所需的信息可能目前尚未掌握，导致产生的目标程序难以达到最优

3. 编译程序的设计目标：规模小速度快（目标程序也需要）、诊断能力强、可靠性高、可移植性好（编译系统规模太大）、可扩充性好

4. 编译程序的划分：前端和后端
   - 前端：与源语言有关、与目标机无关的部分：分析阶段+中间代码生成+与机器无关的代码优化
     **某一种高级语言**在不同机器上的编译系统来说，前端处理基本一样，前端可以复用，只需要针对不同机器构建后端。
   - 后端：与目标机有关的部分：与机器有关的代码优化+目标代码生成
     在**某一种机器上**实现多种高级语言的编译系统，后端可以被服用，只需要针对不同的高级语言构建前端。

### 1.5 编译程序的组织

![image-20201102172227648](https://i.loli.net/2020/11/02/1kcbm9psGSAu4QM.png)

![image-20201102172425013](https://i.loli.net/2020/11/02/be7tMLPEcazGBJg.png)

![image-20201102172506523](https://i.loli.net/2020/11/02/wH7mry1xZLaTI52.png)

![image-20201102172607270](https://i.loli.net/2020/11/02/DHlVSwGA1Luy5P3.png)

![image-20201102172631036](https://i.loli.net/2020/11/02/XHlxQMbgqu8Nnoa.png)

![image-20201102172643647](https://i.loli.net/2020/11/02/ENmGWBrxK9Y5ZkH.png)

## ==Chapter 2 高级语言及其文法==

### 2.1 语言概述

1. 文法：语义的有穷描述
2. 文法分类：
   - 词法/单词：单词的组成规则 【描述方法：BNF范式、正规式】
   - 语法/语句：【描述方法：BNF范式、语法描述图】
3. 语言是信息交流的工具，描述语言需要确定两个方面：描述语言的最小单位（字）和组合字的规则
4. 语言的分类：自然语言和计算机语言（易于形式化）

> **语言**：满足一定条件的**句子**集合
>
> **句子**：满足一定规则的**单词**序列
>
> **单词**：满足词法规则的字符串

> 程序设计语言：组成程序的所有语句集合
>
> **程序**：满足语法规则的**语句**序列
>
> **语句**：满足语法规则的**单词**序列
>
> **单词**：满足词法规则的字符串

### 2.2 基本定义

1. 字母表$\Sigma$：非空有穷集合
2. 字母/字符：字母表$\Sigma$种的元素
   - 整体性：不可划分（原子性）
   - 可辨认性：可区分
   - 两两不同：互异性
3. 字母表乘积：$\Sigma_1\Sigma_2=\{ab|a\in\Sigma_1,b\in\Sigma_2\}$

4. 字母表的幂：
   - $\Sigma^0=\{\epsilon\}$
   - $\Sigma^n=\Sigma^{n-1}\Sigma$

5. 正闭包：$\Sigma^=\Sigma\cup\Sigma^2\cup...$
6. 克林闭包：$\Sigma^=\Sigma^0\cup\Sigma\cup\Sigma^2\cup...$

> - $\epsilon$是空句子或空串，长度为0，也是一个元素
> - $\Sigma^n$即长度为n的字符串集合
> - $\Sigma$字母表中有$m$个元素，那么$\Sigma^n$中就有$m^n$个元素

7. 句子/串：句子/串就是克林闭包上的元素
8. 任意$x,y\in \Sigma^*,a\in \Sigma$，句子xay中的a叫做字符a在这个句子中的一个出现
9. 字符串的长度：句子中字符出现总个数
10. 并置/联结：$x,y\in \Sigma^*$，串x直接联结串y所组成的xy
11. 句子的n次幂：$x^0=\epsilon,x^n=x^{n-1}x$
12. 前缀：x=yz，y为x的前缀，如果$z\neq\epsilon$，那么y是x的真前缀
13. 后缀：x=yz, z为x的后缀，如果$y\neq \epsilon$，那么z是x的真后缀

> 显然，$\epsilon$是所有句子的真前后缀

14. 公共前缀：$x,y,z,w,v\in\Sigma^*,x=yz,w=yv$那么y是x和w的公共前缀，如果x和w的任何公共前缀都是y的前缀，那么y是x和w的最大公共前缀
15. 公共后缀和最大公共后缀：同理
16. 子串：$w,x,y,z\in \Sigma^*$如果w=xyz，那么y是w的子串。同理定义公共子串和最大公共子串。
17. 语言：$\forall L\sube \Sigma^*,$L称为字母表$\Sigma$上的一个语言。语言是一个子集
18. 句子：$\forall x\in L$，x叫做L的一个句子
19. 两个字母表上语言的乘积是这两个字母表的并置/联结上的语言$L_1\sube\Sigma_1^*,L_2\sube\Sigma_2^*$语言，$L_1L_2=\{xy|x\in L_1,y\in L_2\}$
20. 语言的n次幂依然是语言，可以通过乘积定义
21. 语言的正闭包和克林闭包仍然是语言

### 2.3 文法的定义

1. 文法的定义：文法G是一个四元组G=(V,T,P,S), V是非终结符集，T是终结符集，P是产生式集，S是开始符号集

   - 非终结符号集V是还可以继续推导的<font color='red'>元素集合</font>的集合，大写字母，称为语法变量/语法成分——代表某个语言的各种子结构
   - 终结符号集T是里面的每一个终极符号对应于一个元素，即终结符是语言句子里面出现的字符

   - 语法规则集P里面的每一个元素是语法规则，每个语法规则制定了产生句子的过程，是产生式/定义式的集合，产生式$\alpha\to\beta$读作$\alpha$定义为$\beta$。$\alpha$称为左部，$\beta$称为右部。产生式定义各个语法成分的结构（组成规则）
   - 开始符号S一定是非终结符号，从这个开始符号开始推导。开始符号代表文法所定义的语言，至少在产生式左侧出现一次。开始符号一定是非终结符号集中的一个元素。$S\in V$

2. $\alpha$的产生式/候选式：有相同左部的产生式可以合并为，$\alpha\to\beta_1|\beta_2|\beta_3|...|\beta_n$，$\beta_i$称为候选式。

3. 产生式简写：对一个文法G=(V,T,P,S)，只需要列举所有的产生式即可，而且**列举的第一个产生式左部**是该文法的开始符号

4. 判断某个句子是否属于某语言（有了文法/定义句子的规则）

   - 派生/推导（$S\to$符号串）：产生式的右部替换左部  **产生语言的角度**
   - 规约（符号串$\to S$）：产生式的左部替换右部          **识别语言的角度**

5. 推导/直接推导：G是一个文法，如果$\alpha\to\beta\in P,\gamma,\delta\in(V\cup T)^*$则称$y\alpha\delta$在G中直接推导出$y\beta\delta$，即$y\alpha\delta\mathop\Rightarrow\limits_Gy\beta\delta$
6. 规约/直接规约：把$\alpha\ \beta$对调一下。

> $\mathop\Rightarrow\limits_G^+,\mathop\Rightarrow\limits_G^*,\mathop\Rightarrow\limits_G^n,\mathop\Rightarrow\limits_G$分别表示至少1步、多步、n步、一步，每次推导/规约只能替换一个非终结符

7. 句子：开始符号S推导出的**终结符**串
8. 语言：文法G所有**句子**的集合
9. 句型：开始符号S推导出的终结符和非终结符串（每一个中间过程都是）$S\mathop\Rightarrow\limits_G^*\alpha$吗，则$\alpha$是G产生的一个句型,$\alpha\in(V\cup T)^*$

> 对比句子和句型：
>
> 任何文法，句子一定是终结符的集合，句型可以是终结符和非终结符的集合，可以理解为句型可以抽象也可以具体。都是从S开始推导，S就是一个句型但是不是句子。句子一定是句型，但是句型不一定是句子

10. 变量A的集合：$\forall A\in V$，令$L(A)=\{x|A\mathop\Rightarrow\limits^+x\ and\ x \in T^*\}$, $L(A)$就是语法变量A所代表的集合（语法标量通过至少一步可以得到的终结符集合）
11. 文法G的语言：$L(G)=\{w|S\mathop\Rightarrow\limits^+w\ and\ w\in T^*\}$。$\forall w\in L(G)$，$w$称为G产生的一个句子。任意文法G产生的语言就是开始符号S的集合L(S) （语言是句子的集合，这些句子是开始符号经过若干次推导能最终得到终结符的句子）
12. 文法G的作用：文法是语言的有穷描述，以<u>有限的规则</u>（产生式、终结符、非终结符）描述<u>无限</u>（无穷/有穷的句子）的语言现象

### 2.4 文法的分类

- 0型文法（短语结构文本PSG）：满足文法定义（所有文法都是短语结构文法）$\to$短语结构语言PSL

- 1型文法（上下文有关文法CSG）：所有产生式**左部长度<=右部**$\to$1型/上下文有关语言CSL
- 2型文法（上下文无关文法CFG）：所有产生式左部均为**单语法变量**$\to$2型/上下文无关语言CFL<font color="blue">（描述程序语言的多数语法成分）</font>
- 3型文法（正规文法RG）：所有产生式均为$A\to aB$或$A\to a$($A\to Ba$或$A\to a$)$\to$3型/正规集/正则集语言RL<font color="blue">（能描述程序语言的多数单词）</font>
  - 左线性文法（适合推导分析）：$A\to aB$或者$A\to a$
  - 右线性文法（适合归纳分析）：$A\to Ba$或者$A\to a$

1. 文法等价：$L(G_1)=L(G_2)$ 产生的语言相同则文法等价。<font color="green">左线性文法和右线性文法等价</font>，只是识别的方向不同。

2. $RG\sube CFG\sube CSG\sube PSG$,     $RL\sube CFL\sube CSL\sube PSL$
3. 判断文法类别时，$A\to \epsilon$是特殊的产生式，四个文法都可以含有这样的式子。

### 2.5 CFG语法树（分析树/推导树/派生树）

1. 使用CFG树的原因：相对简单，描述能力比较恰当。高级程序设计语言的绝大多数成分都可以用CFG进行描述
2. 语法树：语法成分上下文无关的，即在其句型中总时存在这样的子串，这个子串是由某个变量推导出来的。利用语法树可以给出句型最本质的东西，能更加清晰地表示句型的文法结构和推导和规约的过程
3. 短语：CFG文法G=(V,T,P,S), $\exist\alpha,\beta,\gamma\in(V\cup T)^*,S\mathop\Rightarrow\limits^*\gamma A\beta,A\mathop\Rightarrow\limits^+\alpha$。则称$\alpha$为句型$\gamma\alpha\beta$的相对于变量$A$的短语（子树树根（句型）推出来的东西，短语是子树的结果）
4. 直接短语：$A\mathop\Rightarrow\limits\alpha$，则称$\alpha$是句型$\gamma\alpha\beta$的相对于变量A的直接短语
5. 句柄：最左直接短语

> 树的名词：
>
> 1. 树根：开始符号S
> 2. 中间结点：非终结符V
> 3. 叶节点：终结符/非终结符T
>    - 从根向下推导，任何一层从左到右所有节点的排列是句型（中间结果）
>    - 每个推导对应一个中间节点和它的儿子
> 4. 短语：所有叶子从左到右排列
> 5. 直接短语：只有一代孩子的子树的叶子从左到右排列
> 6. 句柄：分析树最左的只有一代孩子的从左到右排列

- CFG短语：某个句型中A能够推导出$\alpha$，则$\alpha$是该句型的相对于A的短语。在语法树中，某个变量的短语是该子树的所有叶子节点。

- CFG直接短语：A能一步推导出$\alpha$。上述语法树中，保留**仅有父子两代**的子树

- CFG句柄：句型的最左直接短语（用于最左归约）

- 最左推导：每次推导都对最左边的语法变量进行

- 最右规约：对当前举行的最右直接短语进行规约

- 最右推导

- 最左规约/规范规约：一般从左至右分析，符合计算机的逻辑

- CFG二义性：如果一个文法的句子存在两棵分析树，那么这个句子是二义性的，如果一个文法包含二义性的句子，那么这个文法是二义性的。

  消除二义性：改文法，例如定义某些运算的优先级

  > 条件语句经常使用二义性文法描述，因为没有二义性的文法太过于复杂，所以只需要加以限制。让else紧跟最近的if，使得可以在能驾驭的情况下使用二义性文法。
  >
  > 二义性不可判定：对于任何一个CFG，不存在一个算法，可以判定它是无二义性的。可以找到一些**充分条件**，满足充分条件的文法是没有二义性的。

## ==Chapter 3 词法分析==

### 3.1 词法分析器的功能

功能：输入源程序，输出单词符号。即把构成源程序的字符串转换成等价的单词序列
- 根据词法规则识别及组合单词，进行词法检查
- 对数字常数完成数字字符串到二进制数值的转换
- 删除空格和注释等不影响程序语义的字符

#### 一、单词的种类：

1. 关键字/基本字：语句的标识**（数量固定）**
2. 运算符：算术逻辑关系运算符**（数量固定）**
3. 分隔符**（数量固定）**
4. 标识符：用户定义，表示各种名字**（数量不固定）**
5. 常数**（数量不固定）**

#### 二、单词的内部形式

二元组（种别，属性值）

- 种别码表示单词的种类，可以用整数编码或者记忆符表示
- 属性值不同单词值不同

> 两种常用的单词内部表示形式：
>
> 1. 单词种类分类：所有的单词都可以用这个从形式表示，且标识符和常量只能这样表示。同类的单词使用属性值来区分，种别码相同
> 2. 固定数量单词使用一符一类：关键字、运算符、分隔符里面的单词数量固定，所以不再是根据属性值区分，直接每个符号当成一个类来对待。这个时候属性值为空。
>
> 如何存储标识符和常量的属性值？不同方式有什么特点？
>
> 1. 用标识符和常量本身的值来表示：因为属性值长度不固定，所以如果都按照限制的最大长度存，那么<font color='blue'>浪费空间但是便于检索</font>，如果在每个元组的起始位置存元组的长度，必须遍历才可以找到对应位置的元组，<font color='green'>不易检索</font>。
> 2. 指针表示：需要维护一个指针表（索引表/符号表：每个索引固定为4字节，存对应元组的起始位置）这个表长度比较小，不会产生大量的存储空间浪费；易于检索，且因为指针长度确定，所以每个单词的属性值长度相同。到那时访问一个单词时，需要先查表找到对应的位置再访问单词，访问具有间接性；且词法分析器需要查填、维护该表、增加了词法分析器的负担。

#### 三、源程序的输入缓冲与预处理

源程序以字符流的形式存储在外部介质。为了正确识别单词，编译程序需要一系列相关处理。

1. <u>超前搜索</u>和<u>回退</u>：标识符/双字符运算符的识别；<u>回退</u>操作**修正**<u>超前搜索</u>

   > 例如，++a;  读了第一个+还是不能判断单词+还是++所以需要向后再读取一个，读到下一个+之后，指针指向了a，然后再读取a，指针再往后指一个，此时才知道之前的符号是++，这之前所有操作都是为了判断双字符运算符的。词法分析器是一个单词一个单词识别，所以接下来要识别++之后的部分，所以指针需要回退到a，读取a，指针指向a的下一个元素，读到；指针向后一个，此时知道第二个单词是a，然后回退到；读取；

2. 缓冲区：假定源程序存储在磁盘上，这样每次读一个字符就需要访问一次磁盘，效率很低；所以已从从磁盘读取给定大小的部分源程序。

   1. 单缓冲区的问题：

      ![image-20201110200858542](https://i.loli.net/2020/11/10/5MfIB9XHDKdS67G.png)

      - 缓冲区内容用完后，等待新的输入需要等待，应该避免类似的等待。
      - 缓冲区尾部可能只有少部分单词，载入下一部分程序的时候，当前缓冲区的内容被覆盖，**最坏情况下可以识别的单词长度只能为1，而且无法进行超前搜索。**
      - 例：缓冲区大小为N，前面N-1个都读取完毕之后，剩下一个a，不知道a是否是一个完整的单词，所以需要几乎读，这个时候就需要把接下来的输入放在前N-1个缓冲位置。那么假设原来的单词序列是abcd，把bcd放在前N-1个位置之后就变成了bcda！

   2. 双缓冲区：

      ![image-20201110201353344](https://i.loli.net/2020/11/10/GN3bpTd6AhjyMQO.png)

   3. 不带标记的双缓冲：两个指针：一个向前指针：forward，一个开始指针：start。一开始的时候两个指针都在一个单词的开头，然后forward指针向后移动，直到读取到一个单词结束。然后下一个单词的时候，两个指针也都在新单词的头部。每次读取如果forward即将越中间界限，则在另一个缓冲区读取N个字符。然后forward指针指向到另一个缓冲区里。

      <u>==每次读取的时候都需要检查是否到了某半个缓冲区的末尾这样每次都需要两次判断操作，比较麻烦==</u>

   4. 带标记的双缓冲：增加EOF标记。EOF放在每半个缓冲区的末尾（占位），这样每次读取字符的时候，如果不是EOF就不需要单独判断了，如果是EOF的时候，再判断是不是到达了结尾即可。（本身每次读完一个单词的时候 后面也会有一个EOF，所以EOF一个是起到文件末尾的作用，一个是单词之间切换的间隔）

3. 空白字符的剔除：剔除源程序中的无用符号、空格、换行、注释

4. 磁盘结构：

   ![image-20201110204257021](C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201110204257021.png)

   ![image-20201110204043599](https://i.loli.net/2020/11/10/SMaQbF3JdmWcu1Z.png)

#### 四、词法分析阶段的错误处理——5点

1. 非法字符检查：维护一个<u>合法字符集合（一般用哈希表实现）</u>，对于每一个输入字符，判断这个字符是否属于该字符集合。例如，标识符中不能出现除了字母、数字、下划线之外的字符

2. 单词拼写错误：

   - 关键字拼写词法分析阶段没有办法检测，只有语法分析阶段才能发现错误，**词法分析阶段会把这些错误的关键字当作正确的标识符**
   - 标识符拼写错误，例如3b78，处理方式有两种（根据编译器类型）：识别出整数3、标识符b78，或者直接是错误的标识

3. **不封闭错误检查**：如果不限制，那么遇到注释之后，注释后面所有的代码都编程了注释里面的内容，这个显然是不合理的。所以需要对注释/字符串长度加以限制

4. 重复声明检查：词法分析器需要兼顾符号表的查填工作。

   例如，标识符声明的时候就存在与集合中或者这个标识符还有其他属性，那么就用哈希表存这些属性。<key：变量名，value：变量类型等属性>。每次声明一个变量的时候先查表看是否有相同的key

5. 错误恢复（续编译）：

   词法分析阶段的错误使得编译无法继续进行，需要采取措施使得编译继续下去。方法主要是两种：**错误矫正**（很困难）、紧急方式恢复：反复删除剩余输入最前面的字符，直到词法分析器能够发现一个正确的单词为止。

#### 五、词法分析器的位置

把词法分析作为一个单独的阶段，把单词序列按照中间文件的形式存储，作为语法分析的输入。

优点如下:

- 简化编译器的设计
- 提高编译器的效率
- 增强编译器的可移植性

### 3.2 单词的描述

1. 单词是程序设计语言的基本语法单位
2. 如果每一类单词都看作一种语言，那么**大多数**单词词法都可以用正则文法描述。

#### 一、正则文法

1. 正则文法G=(V,T,P,S)中，对$\forall \alpha\to \beta\in P,\alpha\to \beta$均具有形式$A\to w$或$A\to wB$，或者（$A\to w$或$A\to Bw$），其中$A,B \in V$，$w\in T^+$
2. 正则文法描述T上的正则语言。

> 例如 sum, result, a1, b2 四个单词的文法定义如下：
>
> $<id>\to A|B|...|Z|a|b|...|z$
>
> $<id>\to <id>A|<id>B...|<id>Z$
>
> $<id>\to <id>a|<id>b|...|<id>z$
>
> $<id>\to <id>0|<id>1|...|<id>9$
>
> 标识符的文法
>
> $<id>\to <letter>|<id><digit>|<id><letter>$
>
> $<letter>\to A|B|...|Z|a|b|...|z$
>
> $<digit>\to 0|1|2|...|9$

#### 二、正则表达式

正则表达式和正则文法的能力相同，两者都可以描述正则语言和单词，二者可以互相转化。正则表达式更加直观，一般首选正则表达式来表示正则语言。

> 例如标识符的表示：$letter(letter|digit)^*$
>
> - |表示或
> - *
> - +
> - ? 0或1

![image-20201110212258973](https://i.loli.net/2020/11/10/ROZKDv5Xn4H6zbp.png)

正则表达式的运算优先级：

- 克林闭包>连接>或
- 或操作具有交换律和结合律
- 连接具有结合律，以及和对于或操作的分配律
- ()指定优先级，有的时候可以省略

#### 三、正则表达式和正则文法的等价性

1. 等价性描述：任何一个正则文法，一定存在一个同一语言的正则表达式；任何一个正则表达式，一定存在一个同一语言的正则文法；

   ![image-20201111075424699](https://i.loli.net/2020/11/11/fUba9Zo3uqYIzKB.png)

   ![image-20201111075536812](https://i.loli.net/2020/11/11/sKABokZzvhpiRLE.png)

   ![image-20201111075445498](https://i.loli.net/2020/11/11/tuBQWlXpUSiGmdK.png)

   ![image-20201111075451199](https://i.loli.net/2020/11/11/PeVOAEtgcXF4mQ6.png)

2. 例子

   ![image-20201110214246836](https://i.loli.net/2020/11/10/XBQatYzf1jowTU7.png)

   ![image-20201110214301402](https://i.loli.net/2020/11/10/zjGbOCRDKVwiosL.png)

#### 四、有穷状态自动机FA

1. 是正则语言的另一种等价描述

2. 从语言识别的角度实现对于相应语言的刻画

3. 特点：

   - 具有离散输入输出的系统的数学模型
   - 具有**有穷的内部状态**，每个状态的意义不同
   - 系统只需要根据当前所处的**状态**和面临的**输入**就可以确定**后继**的行为。
   - 处理完当前输入之后系统的状态将变化
   - 有**初始**状态，系统在这个状态下开始进行某一个句子的处理
   - 有**终止**状态集合，这个状态表示当前所读入的字符构成的字符串是语言的一个句子

4. 物理模型：![image-20201111075509249](https://i.loli.net/2020/11/11/mTx5G2VOB7yZgrL.png)

   ![image-20201111075516549](https://i.loli.net/2020/11/11/zdTHeQaiqCbfZXj.png)

#### 五、确定的有穷自动机的形式定义

1. DFA的定义如下，是一个五元组$M=(Q,\Sigma,\delta,q_0,F)$，其中
   - Q是一个有穷状态集合
   - $\Sigma$是一个字母表，每个元素都是输入符号
   - $q_0\in Q$,表示初始状态 （显然，初始状态只能有一个）
   - $F\sube Q$, F为终止状态集合 （显然，终止状态可能有很多个）
   - **$\delta$ 状态转移函数**，是一个从$Q\times\Sigma$到$Q$的单值映射，$\delta(p,a)=q\ (p,q\in Q,a\in \Sigma)$表示当前状态为p，输入符号是a的时候，自动机转换到下一个状态$q$。$q$称为$p$的一个后继。这个$\delta$定义了读、改、移的步骤，最为重要

2. 有穷自动机的形式描述

   - 转移函数：  $\delta(p,a)=q$ 枚举

   - 转移矩阵：例如

     |      | a    | b    |
     | ---- | ---- | ---- |
     | 0    | 1    | 2    |
     | 1    | 3    | 2    |

   - 状态转换图（主要用这个，比较直观）

3. DFA M 接受的语言：如果对于所有的$w\in \Sigma^*,q\in Q$以下述方式递归扩展$\delta$的定义

   - $\hat\delta(q,\epsilon)=q$

   - $\hat\delta(q,wa)=\delta(\hat\delta(q,w),a)$

     $\hat\delta和\delta$可以不区分

4. 非确定状态自动机NFA M![image-20201111081533228](https://i.loli.net/2020/11/11/aFoNm7gu5ETxhwZ.png)

   ![image-20201111081551060](https://i.loli.net/2020/11/11/h8tTmv5b7xYpL9o.png)

   ![image-20201111081822867](https://i.loli.net/2020/11/11/R9YiVxJpr1HKeZw.png)
   
   ![image-20201111082010792](https://i.loli.net/2020/11/11/g5FqsvQAY8M3PWt.png)
   
   状态转换图举例：$\epsilon|(0|1)01^* | 0^+$
   
   如果没有边了，一定要加一个$\epsilon$指向终止。同时，或运算可以写在一起。
   
   ![image-20201111083719241](https://i.loli.net/2020/11/11/BzpC89RlsGfqXTd.png)

### 3.3 单词的识别

#### 一、有穷状态自动机和单词识别的关系

1. 单词的识别过程=单词的拼接过程，一个一个字符逐步进行

2. 单词的识别总可以在有限的步骤内完成

3. 单词的识别过程可以看成是有限个状态的变换，每个状态反应某种识别程度

4. 有一个初始状态/若干个终止状态，初始状态表示识别的开始，终止状态表示识别的结束

5. 边上的标记，digit数字，letter字符，other除了离开这个状态的其他边上标记的字符之外的其他字符

6. 识别单词之后转换到另一个状态若需要进行一些的动作，则把动作标在转换后的状态旁边

7. *表示向前指针必须回退一个字符

   ![image-20201111084857694](https://i.loli.net/2020/11/11/Z78eX25OGQUzxys.png)

8. 可以把多个状态合并为一个，因为NFA和DFA等价

9. 利用状态转换图识别单词：

   - 从初始状态出发
   - 读入一个字符
   - 按当前字符转入下一个装后台
   - 重复商量不指导无法继续转移为止

   > 状态$\Leftrightarrow$当前的识别程度，状态转移$\Leftrightarrow$一步推导（读入字符a的时候从状态A转换到状态B正好对应着一步推导过程，即$A\Rightarrow aB$,边正好和产生式相对应）
   >
   > 正则文法$\Rightarrow$状态转换图$\Rightarrow$词法分析程序

#### 二、正则文法构造状态转换图

![image-20201111085732457](C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201111085732457.png)

![image-20201111092943921](https://i.loli.net/2020/11/11/isx6v38DHBocG5P.png)

#### 三、几个典型的单词识别问题

1. 标识符的识别
   - 标识符的最大长度
   - 关键字是否作为保留字，例如DO100I 表示关键字DO 整数100 和标识符 I，如果关键字不可以作标识符，那么关键字就是保留字
2. 关键字的识别：需要超前扫描技术
3. 常数的识别：常数和常量、算术常数、逻辑常数、字符串常数、文字常数
4. 算符和分界符的识别：两个单词有相同前缀时，词法分析器需要用超前搜索技术
5. 回退：利用栈实现回退，超前搜索一般和回退一起出现

#### 四、状态转换图的实现

1. 如果将状态转换图看成是单词的识别规则库，那么单词识别程序从当前状态（初始状态）出发，读入一个字符之后，首先查询这个规则库。
2. 重复以下过程直到到达某一个终止状态：
   - 如果从当前状态出发有一条边上标记了刚刚读入的输入字符，那么单词识别程序将转入这条边所指向的那个状态。并且再次读入一个字符
   - 否则调用出错处理程序
3. 将从初始状态刀终止状态所经历的路径上的字符所组成的字符串作为一个单词输出
4. 并且将当前状态重新置为开始状态，一遍进行下一个单词的是被
5. 如果读完输入字符流之后仍然没有进入某个终止状态则调用出错处理程序

- 方法1：状态矩阵

  ![image-20201111095034282](C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201111095034282.png)

  ![image-20201111095114929](C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201111095114929.png)

- 方法2：邻接表

  ![image-20201111095132584](C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201111095132584.png)

  ![image-20201111095143391](C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201111095143391.png)

- 方法3：四个数组。既可以实现数据压缩存储，又元素的快速访问

  ![image-20201111100901427](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111100901427.png)

  ![image-20201111100925700](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111100925700.png)

  四个数组：

  - default：default[s]表示状态s的默认转向
  - base：base[s]表示状态s对应的转移向量在next和check数组中的起始位置
  - next：next数组以整数为索引，大小和状态转换图里面的边数有关。保存每一个状态s对应的转移向量，按照偏移量存放。某些无转移的符号上，next单元为空。空单元也可也i表示从其他状态转出的状态
  - check：check数组以整数为索引，大小和状态转换图里面的边数有关。标记next中每一个单元的拥有者

  例子：![image-20201111101442446](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111101442446.png)

  ![image-20201111101457801](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111101457801.png)

  将base设置为使得新插入的特殊表项不会与已有表项发生冲突的最小数

  next理解为由当前状态转移所需的条件边，check理解为这个状态的编号

  ![image-20201111101546464](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111101546464.png)

  

### 3.4 词法分析程序的自动生成

![image-20201111102457655](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111102457655.png)

![image-20201111102506282](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111102506282.png)

![image-20201111102526138](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111102526138.png)

![image-20201111102539875](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111102539875.png)

![image-20201111102552102](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111102552102.png)

![image-20201111102600284](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111102600284.png)

> 小结：
>
> ![image-20201111103458807](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111103458807.png)
>
> ![image-20201111103504360](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111103504360.png)

## ==Chapter 4 自顶向下的语法分析==

### 4.1 语法分析概述

经过词法分析器，得到了去除空格、注释等的单纯的单词序列，然后进入语法分析器，判断这个单词序列是否满足规则，即这个单词序列是否是源语言的句子。

#### 一、语法分析的功能和位置

1. 语法分析是编译程序的核心部分，任务是<u>检查词法分析器输出的单词序列是否是源语言中的句子</u>，即<u>是否符合源语言的语法规则</u>。

   ![image-20201111153309835](D:%5Csubject%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets%5Cimage-20201111153309835.png)

2. 语法分析的主要工作：根据源语言的文法，判断某一个单词序列是否是源语言的一个句子（这里判别的是单词序列，但是不一定满足文法的产生式，所以不一定是句子）

   > 语言：满足一定组成规则（文法中的产生式）的句子集合
   >
   > 句子：满足一定组成规则（文法中的产生式）的单词序列
   >
   > 单词：满足一定组成规则（文法中的产生式）的字符串

3. 判断某一个单词序列是否是源语言的句子的方法：
   - 产生句子的方式：从文法的开始符号开始，逐步推导出这个单词序列，称为自顶向下的语法分析。主要的方法是**递归子程序法**和**预测分析法**（LL(1)）<font color='red'>从根开始逐步为某语句构造一棵语法树</font>
   - 识别句子的方式：逐步将构成程序的单词序列规约为文法的开始符号，称为自底向上的语法分析。主要的方法是**算符优先分析法**和**LR(0)、SLR(1)、LR(1)、LALR（1）**<font color='red'>将一个句子规约为开始符号</font>

