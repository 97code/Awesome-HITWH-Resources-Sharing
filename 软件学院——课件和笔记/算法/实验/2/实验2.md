

由$dp[i]$的定义可知，$i$已经包含在最长递增子序列中，因此由定义可知，其一定不在$lis_i$中。反之，如果$a[i]\leq a[j]$，我们证明其一定在$lis_i$中。如若不然

## 优化解结构

我们首先定义数组$dp$，$dp[i]$表示以$i$为结尾的最长递增子序列$lis_i$。定义集合$S=\{j|0\leq a[j]\leq a[i],j<i\}$。必然存在一个j，使得a[j]在$lis_i$中(否则，$lis_i=a[i]$，加入$a[j]$之后依然满足最长递增子序列的定义，矛盾！)那么我们有：
$$
lis_i=lis_j+a[i]
$$
j的选择不唯一。

我们证明:$lis_j$是以j为末尾的最长递增子序列。反之，存在其最长子序列为L，那么由于a[i]>a[j]，所以a[i]$\notin$L，因此L+a[i]为L的一个递增子序列，且长度大于$lis_i$，矛盾！因此我们证明了该问题具有优化解结构。

## 重叠子问题

![Visio-绘图1](https://i.loli.net/2020/10/19/1WtGUmQed3unsLk.jpg)

由于我们从大到小求解，所以求解的时候对于不同的j的选择，具有相同的子问题重叠。

## 递归求解

- dp[0:n-1]: dp[i]记录以第i个元素为结尾构成的最长递增序列长度
- pre_node[0:n-1]：pre_node[i]记录以第i个元素为结尾构成的序列前一个元素（用于构造最优解）
- path[0:n-1]：path[i]记录以第i个元素为结尾构成的最长递增序列

我们经过上述的推导知，
$$
dp[i]=\max_{0\leq j<i\\a[j]\leq a[i]} \{dp[j]+1\},\ i>0
$$

$$
dp[i]=0,\ i=0
$$



当选择完j之后我们记录pre_node[i]=j。

## 伪代码描述

```c++
getLisInfo(a){
  for i <- 0 to n-1:
  	dp[i] <- 1;
  	pre_node[i] <- i;
  
  for j <- 0 to n-1:
    for i <- 0 to j-1:
        if a[i]<=a[j] and dp[j]<dp[i]+1
            dp[j]<-dp[i]+1; //更新dp[j]为最大的值
            pre_node[j]<-i; //记录选择的j   
}

```

以i为尾的lis至少包含a[i]，所以dp[i]初始化为1；pre_node[i]默认指向自己。

## 构造最优解

最优解的信息可以通过pre_node直接求出，我们把最后的结果存储在了path中。

```python
getPath(pre_node,a):
  for j in range(n):
    path[j] <- path[pre_node[j]] + j;
```



## 可视化结果

我们随机采样一组30个点，然后做出lis的图像。其中x轴为序列元素的下标，y轴为每个序列元素的值。

![path](https://i.loli.net/2020/10/19/BeCbvUaHunGiA9y.png)









